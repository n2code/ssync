#!/bin/bash

function errecho {
	echo -e "$1" 1>&2
}

if [[ $EUID -ne 0 ]]; then
	errecho "This must be run as root."
	exit 1
fi


SCRIPT="${BASH_SOURCE[0]}"
if [[ -L "$SCRIPT" ]]; then SCRIPT="$( readlink -ms "$SCRIPT" )"; fi
DIR="$( dirname "$SCRIPT" )"

if ( test ! -f "$DIR/settings.inc" ) || ( cmp -s "$DIR/settings.inc.template" "$DIR/settings.inc" >/dev/null ); then
	cp "$DIR/settings.inc.template" "$DIR/settings.inc"
	if [[ ! -e "/usr/local/bin/ssync" ]]; then ln -s "$DIR/ssync" "/usr/local/bin/ssync"; fi
	echo "Welcome to ssync!
A default configuration was copied to $DIR/settings.inc
Edit this file and restart this setup by using
    ssync setup
to pull the ssync repository from GITURL or even
    ssync setup new
for first use of this tool ever (this initializes a fresh repo and pushes it upstream)."
	exit 1
fi

source "$DIR/settings.inc"
PERMFILE="ssync-file-permissions"
LINKINDEX="ssync-linkindex"

function helphint {
	errecho " => ssync help"
}

function usagehelp () {
	echo "
USAGE: ssync [verbose] COMMAND

COMMANDS:
    setup [new]
          Initializes ssync. If settings file is not found a template is created
          and the user is prompted to edit it and execute this command again.
          Adding the \"new\" option creates the necessary repository structures
          and pushes them to an empty git repository with the specified GITURL,
          otherwise it is simply cloned.

    add PATH
          Move file or folder to repository to enable synchronization. This
          creates a symlink in its original place.

    rm PATH
          Unlink element in repository and restore original file/folder. It is
          not possible to remove children of a linked parent folder.

    check PATH
          Query if path is part of repository.

    status
          Display changes since last commit (added or removed entries).

    commit [MESSAGE]
          Bundle changes in a commit for synchronization.

    links
          List paths of all repository elements.

    git ...
          Pipe git command through to underlying git."
}

function sync_setup {
	if [[ "$1" == "new" ]]; then
		echo "SYSTEMSYNC-REPO-CREATION"
		echo "########################"

		TEMPREPO="$(mktemp -d)"
		cd "$TEMPREPO"
		touch "$PERMFILE" "$LINKINDEX"
		git init .
		git config user.name "ssync"
		git config user.email "ssync@localhost"
		git add --all
		git commit -m "initialized ssync repository"
		git remote add origin "$GITURL"
		git push -u origin master || ( errecho "Upload failed, aborting setup." && exit 1 )

		rm -r "$TEMPREPO"
	fi

	echo "SYSTEMSYNC-SETUP"
	echo "################"
	cd "$DIR"

	echo "Cloning system config repo..."
	if ! git clone "$GITURL" "$SYNCREPO"; then
		errecho "CLONE FAILED." && exit 1
	fi

	echo "Setting up hooks..."
	echo -e "#!/bin/bash\n$DIR/ssync fix" > "$SYNCREPO/.git/hooks/post-checkout"
	chmod u+x "$SYNCREPO/.git/hooks/post-checkout"
	cp "$SYNCREPO/.git/hooks/post-checkout" "$SYNCREPO/.git/hooks/post-merge"

	echo "(Re)Linking ssync in /usr/local/bin ..."
	rm "/usr/local/bin/ssync" 2> /dev/null
	ln -s "$DIR/ssync" "/usr/local/bin/ssync"

	echo "Setting up local repository..."
	cd "$SYNCREPO"
	git config user.name "$GITUSER"
	git config user.email "$GITEMAIL"
	git config push.default matching
	git checkout -f "$GITBRANCH"

	echo "################"
	echo "Setup complete."
}

function is_indexed {
	local MATCHES

	MATCHES="$(grep --count --fixed-strings --line-regexp "$2" "$1")"
	case "$MATCHES" in
		"0") return 42;;
		"1") return 0;;
		*) errecho "WARNING: $1 corrupt. Duplicate entries!"; return 0;;
	esac
}

function add_to_index {
	local INDEXFILE="$1" LOCATION="$2"

	if is_indexed "$INDEXFILE" "$LOCATION"; then
		errecho "WARNING: Attempt to add already index entry to $1"
	else
		echo "$LOCATION" | LC_ALL=C sort -o "$INDEXFILE" - "$INDEXFILE"
	fi
}

function remove_from_index {
	local INDEXFILE="$1" LOCATION="$2"

	if ! is_indexed "$INDEXFILE" "$LOCATION"; then
		errecho "WARNING: Attempt to remove non-indexed entry from $INDEXFILE"
	else
		cp -a "$INDEXFILE" "$INDEXFILE.tmp"
		grep --invert-match --fixed-strings --line-regexp "$LOCATION" "$INDEXFILE.tmp" > "$INDEXFILE"
		rm "$INDEXFILE.tmp"
	fi
}

function is_child_of {
	local CHILD PARENT REDUCED

	#resolve links
	CHILD="$(readlink -m "$1")"
	PARENT="$(readlink -m "$2")"
	
	#strip repo if currently synced
	CHILD="${CHILD##"$SYNCREPO/files"}"
	PARENT="${PARENT##"$SYNCREPO/files"}"

	#remove base from path and see if path has changed (check for starting slash to account for partial directory names having been removed)
	REDUCED="${CHILD##"$PARENT"}"
	if [[ "$REDUCED" != "$CHILD" ]] && [[ "$REDUCED" == /* ]]; then return 0; else return 1; fi
}

function is_in_repo {
	local TESTED="$1" LINE

	while read LINE; do
		if [[ "$TESTED" == "$LINE" ]] || is_child_of "$TESTED" "$LINE"; then return 0; fi
	done <"$SYNCREPO/$LINKINDEX"
	return 1
}

function add_clone_link {
	local ORIGINAL="$1" LINK="$2"

	( echo -n "Creating link: " >&9 \
	&& ln --symbolic --verbose -- "$ORIGINAL" "$LINK" >&9 \
	&& chown --no-dereference --reference="$ORIGINAL" --verbose -- "$LINK" >&9 \
	&& chmod --reference="$ORIGINAL" --changes -- "$LINK" >&9 \
	&& return 0 ) || return 1
}

function sync_add {
	local PASSED="$1" TARGET

	TARGET="$SYNCREPO/files$PASSED"

	if is_in_repo "$PASSED"; then
		errecho "ERROR, already part of repository $SYNCREPO"
	elif [[ -L "$PASSED" ]]; then
		errecho "ERROR, symlinks cannot be synced"
	elif [[ -e "$PASSED" && ( -d "$PASSED" || -f "$PASSED" ) ]]; then
		if [[ -d "$PASSED" ]]; then
			SUCCESSMESSAGE="Directory sync added."
		elif [[ -f "$PASSED" ]]; then
			SUCCESSMESSAGE="File sync added."
		fi

		rsync --recursive --links --perms --times --group --owner --relative --devices --specials --verbose "$PASSED/" "$SYNCREPO/files/" >&9 \
		&& rm --recursive --verbose -- "$PASSED" >&9 \
		&& echo "Relinking former location..." >&9 \
		&& add_clone_link "$TARGET" "$PASSED" \
		&& add_to_index "$SYNCREPO/$LINKINDEX" "$PASSED" \
		&& echo "$SUCCESSMESSAGE" >&9
	else
		errecho "ERROR, source directory or file not found"
	fi
}

function sync_rm {
	local PASSED="$1" REPODATA

	REPODATA="$SYNCREPO/files$PASSED"

	if ! is_indexed "$SYNCREPO/$LINKINDEX" "$PASSED"; then
		errecho "ERROR, no repository link (see: ssync links)"
	elif [[ ! -L "$PASSED" ]]; then
		errecho "ERROR, no symlink encountered"
		errecho "WARNING: $SYNCREPO/$LINKINDEX corrupt. Link missing!"
	else
		rm --verbose "$PASSED" >&9 \
		&& rsync --recursive --links --perms --times --group --owner --relative --devices --specials --verbose "$SYNCREPO/files/.$PASSED" "/" >&9 \
		&& rm -r --verbose "$REPODATA" >&9 \
		&& remove_from_index "$SYNCREPO/$LINKINDEX" "$PASSED" \
		&& echo "Restored at original location." >&9
	fi
}

function sync_commit {
	cd "$SYNCREPO"
	save_permissions
	git add --all

	MSG="System update: $( git diff --staged --stat | tail -n1 )"
	if [[ ! -z "$1" ]]; then MSG="$1"; fi
	git commit -m "$MSG"
}

function sync_show_index {
	cat "$SYNCREPO/$LINKINDEX"
}

function sync_status {
	cd "$SYNCREPO" && git --no-pager diff "$LINKINDEX" | grep -E "^[+-]/.+$" | LC_ALL=C sort
}

function sync_check {
	if is_in_repo "$1"; then
		echo "In ssync repository."
	else
		echo "Not in repository."
	fi
}

function save_permissions {
	local LINE HIT

	while read LINE; do
		HIT="${LINE##"$SYNCREPO/files"}"
		if is_in_repo "$HIT"; then
			echo "$(stat --printf="%04a:%U:%G" "$LINE"):$HIT"
		fi
	done < <(find "$SYNCREPO/files" -mindepth 1 | LC_ALL=C sort) > "$SYNCREPO/$PERMFILE"
}

function restore_permissions {
	local MOD USER GROUP LOCATION

	echo "Adjusting permissions..."
	while IFS=: read -r MOD USER GROUP LOCATION; do
		LOCATION="$SYNCREPO/files$LOCATION"
		if [[ -e "$LOCATION" ]]; then
			if [[ "$USER:$GROUP" != "$(stat --printf="%U:%G" "$LOCATION")" ]]; then
				chown --changes -- "$USER:$GROUP" "$LOCATION" >&9
			fi
			if [[ "$MOD" != "$(stat --printf="%04a" "$LOCATION")" ]]; then
				chmod --changes "$MOD" "$LOCATION" >&9
			fi
		else
			errecho "$LOCATION not found, permission restore failed."
		fi
	done < "$SYNCREPO/$PERMFILE"
}

function ask_confirm {
	local MESSAGE="$1" ANSWER
	while [[ ! "$ANSWER" =~ ^[yYnN]$ ]]; do
		if ! read -r -n 1 -p "$MESSAGE [y/n]: " -t 99 ANSWER; then
			ANSWER="n"
			echo -n "$ANSWER (chosen by timeout)"
		fi
		echo
	done
	if [[ "$ANSWER" =~ ^[yY]$ ]]; then return 0; else return 1; fi
}

function sync_fix {
	local LOCATION TARGET REALLOCATION PROBLEMS=0

	echo "Checking local repository against index..."
	while read -u 3 LOCATION; do
		TARGET="$SYNCREPO/files$LOCATION"
		echo -n "$LOCATION => " >&9
		if [[ -L "$LOCATION" ]]; then
			REALLOCATION="$(realpath --quiet --canonicalize-missing "$LOCATION")"
			if [[ "$REALLOCATION" == "$SYNCREPO/files/"* ]]; then
				echo "ok" >&9
			else
				echo "LINK CONFLICT!" >&9
				errecho "The indexed symlink is not pointing to the repository as expected: $LOCATION"
				if ask_confirm "Delete existing symlink and link to repository instead?"; then
					( rm -- "$LOCATION" \
					&& add_clone_link "$TARGET" "$LOCATION" ) \
					|| ( errecho "Correcting link failed." && ((PROBLEMS++)) )
				else ((PROBLEMS++)); fi
			fi
		elif [[ -e "$LOCATION" ]]; then
			echo "CONTENT CONFLICT!" >&9
			errecho "Symlink to repository expected but file/folder found: $LOCATION"
			if ask_confirm "Delete existing file/folder and link to repository instead?"; then
				( rm -i -- "$LOCATION" && [[ ! -e "$LOCATION" ]] \
				&& add_clone_link "$TARGET" "$LOCATION" ) \
				|| ( errecho "Linking failed." && ((PROBLEMS++)) )
			else ((PROBLEMS++)); fi
		else
			echo "adding..." >&9
			add_clone_link "$TARGET" "$LOCATION" \
			|| ( errecho "Adding link failed." && ((PROBLEMS++)) )
		fi
	done 3<"$SYNCREPO/$LINKINDEX"

	restore_permissions

	if (( $PROBLEMS > 0 )); then
		errecho "[!] WARNING: $PROBLEMS problem(s) unresolved and remaining. Re-run \"ssync fix\" to check again."
	else
		echo "[i] Repository state clean."
	fi
}

#MAIN FLOW

#file descriptor #9 is our verbose output, all superfluous information goes there
if [[ "$1" == "verbose" ]]; then
	shift
	exec 9>&1
else
	exec 9>/dev/null
fi

MAINARG="$1"
shift

case "$MAINARG" in add|rm|check|commit|links|status|git|fix) if [[ ! -e "$SYNCREPO/.git" ]]; then
	errecho "ERROR: Setup not completed."
	helphint && exit 1
fi;; esac

case "$MAINARG" in
	setup)
		sync_setup "$1";;
	fix)
		sync_fix;;
	add|rm|check)
		while : ; do
			#calculate resolved non-repo path
			FULLPATH="$(realpath --quiet --canonicalize-missing --no-symlinks "$1")"
			FULLPATH="${FULLPATH##"$SYNCREPO/files"}"

			if [[ -z "$FULLPATH" ]]; then
				errecho "ERROR, no path given!"
				helphint && exit 1
			fi

			case "$MAINARG" in
				add) sync_add "$FULLPATH";;
				rm) sync_rm "$FULLPATH";;
				check) sync_check "$FULLPATH";;
			esac
			shift
			[[ "$1" ]] || break
		done
		;;
	commit)
		sync_commit "$1";;
	links)
		sync_show_index;;
	status)
		sync_status;;
	git)
		case "$1" in
			add|rm|commit)
				errecho "Please use the designated ssync commands instead of git $1"
				helphint && exit 1
				;;
			mv|clean)
				errecho "You should avoid these commands to keep ssync working properly.\nIf you are sure about what you are doing, specify an override:\n    git override $1 ..."
				exit 1
				;;
			override)
				shift
				;;
			*)
				cd "$SYNCREPO" && git "$@"
				;;
		esac
		;;
	*)
		usagehelp;;
esac

if [[ "$VERBOSE" == "yes" ]]; then
	echo "$OUTPUT"
fi
#EOF
